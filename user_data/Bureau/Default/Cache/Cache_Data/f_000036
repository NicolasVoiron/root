var chartsData = {
  containerid: null,
  startDate: null,
  showedCharts: [],
  firstLevelBarCharts: {
    planningAdhesion: planningAdhesion,
    planningConformity: planningConformity,
    planningNok: planningNok
  }
};
var txtStyle = {};
var dark = true;

var API_URLS = {
  adhesion: {
    base: '/api/kpi/planningAdhesion/months/6/',
    users: '/api/kpi/planningAdhesion/month/users',
    themes: '/api/kpi/planningAdhesion/month/themes/'
  },
  conformity: {
    base: '/api/kpi/conformityAuditedCards/months/6/',
    users: '/api/kpi/conformityAuditedCards/month/users/',
    themes: '/api/kpi/conformityAuditedCards/month/themes/'
  },
  nok: {
    base: '/api/kpi/nokAuditedCards/'
  }
};

/**
 * Charge the planning Conformity Graphic
 * @param {TaskManager[]} taskmanagers : List of taskmanagers
 * @param {Object} filters : Filters including sector_services and places
 */
async function planningAdhesion( taskmanagers, filters = {} ) {
  let url = API_URLS.adhesion.base;
  let planningClass = 'planningAdhesionContainer';
  await chargePlanning( url, planningClass, taskmanagers, filters );
  return;
}


/**
 * Charge the planning Conformity Graphic
 * @param {TaskManager[]} taskmanagers : List of taskmanagers
 * @param {Object} filters : Filters including sector_services and places
 */
async function planningConformity( taskmanagers, filters = {} ) {
  let url = API_URLS.conformity.base;
  let planningClass = 'planningConformityContainer';
  await chargePlanning( url, planningClass, taskmanagers, filters );
  return;
}

/**
 * * Create Pareto NOK Chart graphic
 * @param {TaskManager[] | String } taskmanagers : List of taskmanagers Objects or list of ids
 * @param {Object} filters : Filters including sector_services and places
 */
function planningNok( taskmanagers, filters = {} ) {
  let refreshTable = () => {
    planningNok( taskmanagers, filters );
  };

  let url = API_URLS.nok.base;
  let planningClass = 'planningNokContainer';
  taskmanagers = taskmanagers.map( t => ( typeof t == 'object' && t._id ) ? t._id : t );

  $( '.kpiNokParetoContainer' ).find( `.${planningClass}` ).remove();

  let start = $( '#date-nok-start' ).val();
  start = moment( start, 'DD/MM/YYYY' ).format( 'YYYY-MM-DD' );
  let end = $( '#date-nok-end' ).val();
  end = moment( end, 'DD/MM/YYYY' ).add( 1, 'days' ).format( 'YYYY-MM-DD' );

  let dates = {
    startDate: start,
    endDate: end
  };

  let ajxReq = new Promise( ( resolve, reject ) => {
    AJAXRequestGRaphics( url, taskmanagers, filters, dates )
      .then(
        data => {
          data = data.map( val  => {
            val.label = val.theme.name;
            val.textColor = '#000000';
            val.value = Math.round( val.count );
            val.itemStyle = {
              color: val.theme.color
            };
            return val;
          } );

          let labels = data.map( val => val.label );

          // Create Graphic
          let elemCont = $( '<div class="planningNokContainer"></div>' );
          let elem = $( '<div class="graphDimensions"></div>' );
          $( elemCont ).html( elem );
          $( '.kpiNokParetoContainer' ).prepend( elemCont );

          let myChart = echarts.init( $( elem )[ 0 ], '#fac858' );

          let opt = setNoData();

          if ( data.length > 0 ) {
            opt = drawGraphicPareto( labels, data, TOTAL );
          }

          myChart.setOption( opt );

          myChart.on( 'click', function( event ) {
            let urlSend = `${url}${event.data.theme._id}`;
            AJAXRequestGRaphics( urlSend, taskmanagers, filters, dates )
              .then(  newData => {
                // If something has changed in data, reload the planning
                let oldCountForTheme = data.find( d => d.theme._id == event.data.theme._id ).count;
                if ( newData.length != oldCountForTheme ) {
                  refreshTable();
                }

                createTableInfoKpi( newData, refreshTable );
              } ).catch( e => {
                console.log( 'Error', e );
              } );
          } );

          window.addEventListener( 'resize', function() {
            myChart.setOption( opt, true );
          } );

          resolve( data );
          Evnt.emit( 'Graphic Set' );
        }
      ).catch( e => {
        reject( e );
      } );
  } );

  return ajxReq;
}

/**
 * Charge an specific planning
 * @param {*} url : API url to get the information of the graphic
 * @param {*} classPlanning : The class of the html element
 * @param {*} taskmanagers : The list of taskmanagers objects
 * @param {Object} filters : Filters including sector_services and places
 * @returns
 */
async function chargePlanning( url, classPlanning, taskmanagers, filters ) {
  taskmanagers = taskmanagers.map( t => ( typeof t == 'object' && t._id ) ? t._id : t );

  let endDateDaily = moment().endOf( 'day' );
  let endDateWeekly = endDateDaily.clone().startOf( 'isoWeek' ).day( 5 ).endOf( 'day' );

  let startDateDaily = endDateDaily.clone().startOf( 'month' ).subtract( 5, 'month' ).startOf( 'month' );
  let startDateWeekly = endDateWeekly.clone().startOf( 'month' ).subtract( 5, 'month' ).startOf( 'month' );

  let dates = {
    daily: {
      endDate: endDateDaily.toISOString(),
      startDate: startDateDaily.toISOString(),
      offsetStart: startDateDaily.utcOffset(),
      offsetEnd: endDateDaily.utcOffset()
    },
    weekly: {
      endDate: endDateWeekly.toISOString(),
      startDate: startDateWeekly.toISOString(),
      offsetStart: startDateWeekly.utcOffset(),
      offsetEnd: endDateWeekly.utcOffset()
    }
  };

  return new Promise( ( resolve, reject ) => {
    AJAXRequestGRaphics( url, taskmanagers, filters, dates )
      .then( async data  => {
        let values = data.values;
        let adhesionGoals = data.goals ? data.goals : {};
        $( `.${classPlanning}` ).remove();
        values.forEach( ( val, i ) => {
          val.label = val.label_month = MONTHSLABELS_SHORT[ val.label.toUpperCase() ]/*.substring(0, 3)*/;
          val.label_mont_large = MONTHS_LABELS[ val.label.toUpperCase() ];
          val.bgColor = i === data.length - 1 ? '#d7e3ee' : '#8abde8';
          val.textColor = '#000000';
          val.value = Math.round( val.value );
          val.goal = adhesionGoals[ val.monthKey ];
          //d.value = Math.floor(Math.random() * 100);
        } );
        await createGraphic( classPlanning, values, taskmanagers, filters );

        resolve( data );
      }
      ).catch( e => reject( e ) );
  } );
}

/**
 * Create datatable with data selected information
 * @param {Array} data : Array of tasks of selected period
 * @param {Function} refreshTable : Function to refresh the information table
 */
async function createTableInfoKpi( data, refreshTable ) {
  let columns_labels = {
    title: 0,
    taskmanager: 1,
    user: 2,
    sector_service: 3,
    delivery_date: 4,
    read: 5
  };

  let container = $( '#kpi-table-info' );
  $( container ).hide();
  let tableHTML = $( container ).find( 'table' );

  // Destroy datatable befor constructing a new one
  try {
    tableHTML.DataTable().destroy();
  } catch ( e ) {
    console.log( e );
  }

  let tbody = $( tableHTML ).find( 'tbody' );
  $( tbody ).html( '' );

  // Up to date adminSpec global variable
  let taskManagersId = data.map( t => t.cftaskmanager_id ).flat();
  taskManagersId = [ ...new Set( taskManagersId ) ]; // Remove duplicated ids
  let taskmanagersObjects = await TaskManager.getManyById( taskManagersId );

  let isAdminInTaskmanagers = {};
  taskmanagersObjects.forEach( tskM => {
    let adminIntskM = ( tskM.admin.indexOf( userID ) >= 0 );
    isAdminInTaskmanagers[ tskM._id ] = adminIntskM;
  } );

  // Add row to table with data information
  data.forEach( task => {
    let taskmanagerId_task = task.cftaskmanager_id[ 0 ];
    let taskmanagerObj = taskmanagersObjects.find( t => t._id == taskmanagerId_task );
    let date = moment( task.delivery_date, 'YYYY-MM-DD' );
    let user = task.users[ 0 ];

    let canModify = ( ( admn || isAdminInTaskmanagers[ taskmanagerId_task ] ) ||  user._id == userID ); // The user can modify if he is an admin or he is the auditor
    let showTaskPencil = $( '<i class="fas fa-pencil-alt"></i>' );

    // Create row
    let tr = $( `<tr>
      <td>${taskmanagerObj.name}</td>
      <td>${task.cardClass.title}</td>
      <td>${user.lastname} ${user.firstname}</td>
      <td>${task.cardClass.uap_services[ 0 ]}</td>
      <td>${date.format( 'DD/MM/YYYY' )}</td>
      <td style="width: fit-content;">${isTrue( task.history_status.readed ) ? YES : NO }</td>
      <td class="showTaskEye" style="max-width: fit-content; min-width: fit-content; width: fit-content;"></td>
    </tr>` );


    // If the user can modify we add the element and set the listeners
    if ( canModify ) {
      tr.find( '.showTaskEye' ).append( showTaskPencil );
      showTaskPencil.on( 'click', async () => {
        let objCard = {
          ...task.cardClass,
          ...task,
          history_status: [ task.history_status ],
          users: task.users.map( u => u._id )
        };

        let taskManagerObject = taskmanagersObjects.find( t => t._id == taskmanagerId_task );
        let taskManagerClass = new TaskManager( { _id: taskManagerObject._id } ); // Create an instance for the object

        try {
          // Load object for the global variable
          taskManager = await taskManagerClass.load();
        } catch ( e ) {
          console.log( 'Error ! ', e );
        }

        const modal = $( '#modal-update-task' );

        const modal_elements = await openPopupUpdateTask( objCard );

        // Take off the default action buttons
        modal_elements.buttons.ok.element.off( 'click' );
        modal_elements.buttons.na.element.off( 'click' );
        modal_elements.buttons.read.element.off( 'click' );


        let taskInstance = new Card( objCard );

        // Reset modify listeners
        const modalComment = $( '#modal-complete-comment' );
        modalComment.find( '#complete_commentary_action' )
          .off( 'click' )
          .on( 'click', function() {
            var $textarea = $( modalComment ).find( 'textarea' );

            var comment = $textarea.val();
            if ( comment ) {
              taskInstance.setLastComment( comment )
                .then( newComment => {
                  let lastHistory = taskInstance.history_status[ taskInstance.history_status.length - 1 ];
                  lastHistory.comment = `${lastHistory.comment}\n\n${newComment}`;

                  $textarea.val( '' );
                  $( '#modal-card-commentary' ).append( '<p class="last_comment">' + newComment + '</p>' );
                  modalComment.modal( 'hide' );
                } )
                .catch( err => {
                  closeModal( modalComment );
                  showErrorCode( err );
                } );
            }
          } );

        let refresh = ( data, filter ) => {
          refreshTable();
          createTableInfoKpi( data, refreshTable ); // Recreate table information

          // If the new data is empty, hide the table information
          if ( data.length == 0 ) {
            $( '#kpi-table-info' ).hide();
          }
        };

        modal_elements.buttons.ok.element
          .off( 'click' )
          .on( 'click', async () => {
            try {
              await modal_elements.buttons.ok.setStatus();
              data = data.filter( d => d._id != taskInstance._id );
              refresh( data, true );
            } catch ( e ) {
              if ( e.error_code == 'XSS_INJECT' ) {
                return showErrorCode( e );
              }
              console.error( e );
            }
          } );

        modal_elements.buttons.na.element
          .off( 'click' )
          .on( 'click', async () => {
            try {
              await modal_elements.buttons.na.setStatus();
              data = data.filter( d => d._id != taskInstance._id );
              refresh( data, true );
            } catch ( e ) {
              if ( e.error_code == 'XSS_INJECT' ) {
                return showErrorCode( e );
              }
              console.error( e );
            }
          } );

        // SET READ
        modal_elements.buttons.read.element
          .off( 'click' )
          .on( 'click', async () => {
            try {
              await modal_elements.buttons.read.setRead();
              let { history_status } = data.find( t => t._id == taskInstance._id );
              history_status.readed = true;
              closeModal( modal );
              refresh( data, false );
            } catch ( e ) {
              showErrorCode( e );
            }
          } );
      } );
    }
    $( tbody ).append( tr );
  } );

  // Params in datatable set to true
  let params = {
    'ordering': true,
    columnDefs: [ {
      targets: '_all',
      sortable: false
    } ],
    responsive: true
  };

  const dataTable = createDataTable( tableHTML, params );

  $( container ).show();

  $( 'html' ).animate( {
    scrollTop: $( '#kpi-table-info' ).offset().top,
  },
  300
  );

  // Resize columns based on content
  $( tableHTML ).find( '.sort-button' ).on( 'click', e => {
    var $this = $( e.currentTarget );
    var $th = $this.closest( 'th' );
    var label = $th.attr( 'label' );

    $th.parent().find( 'th span.active' ).removeClass( 'active' );

    if ( $this.hasClass( 'up' ) ) {
      dataTable.order( [ columns_labels[ label ], 'asc' ] ).draw();
    } else if ( $this.hasClass( 'down' ) ) {
      dataTable.order( [ columns_labels[ label ], 'desc' ] ).draw();
    }
  } );
}

/**
 *
 * @param {*} url : API url to get the information of the graphic
 * @param {*} taskmanagers : The list of taskmanagers objects
 * @param {Object} dates : Dates to know when start and end the query
 * @param {Object} filters : Filters including sector_services and places
 * @returns
 */
async function AJAXRequestGRaphics( url, taskmanagers, filters, dates ) {
  let data = {
    taskmanagers: taskmanagers,
    dates: dates,
    filters
  };
  return new Promise( ( resolve, reject ) => {
    $.ajax( {
      method: 'GET',
      url: url,
      data: data,
      success: data => {
        resolve( data );
      },
      error: er => {
        reject( er );
      }
    } );
  } );
}

/**
 * Create a graphic chart
 * @param {string} nameHTML : Name of the element containter to create
 * @param {array} data : Data information
 * @param {TaskManager[]} taskmanagers : List of taskmanagers
 * @param {Object} filters : Filters including sector_services and places
 */
async function createGraphic( nameHTML, data, taskmanagers, filters ) {
  let elemCont = $( `<div class="${nameHTML}"></div>` );
  let elem = $( '<div class="graphDimensions"/>' );
  let titleContainer = $( '<div style="color: black; width: 100%; text-align: center;"><b></b></div>' );
  $( elemCont ).html( [ titleContainer, elem ] );
  $( '#principalContent-kpi .kpisRate' ).append( elemCont );

  let myChart = echarts.init( $( elem )[ 0 ], '#fac858' );

  let months = data.map( e => { return e.label; } );
  let values = data.map( e => {
    return {
      value: e.value,
      itemStyle: {
        color: 'rgba(0, 170, 196, 0.5)'
      },
      label_month: e.label_month,
      month: e.month,
      years: e.years,
      goal: e.goal
    };
  } );

  let title = '';
  let btns = $( '<div class="buttonsMonths">' );

  async function createButtonActionForAdhesion( e ) {
    const modal = $( '#modal-general-confirm' );
    modal.find( '.modal-title' ).html( e.label_month );

    let datesDaily = getIntervalDatesForElement( e, false );
    datesDaily.startDate = datesDaily.startDate.toISOString();
    datesDaily.endDate = datesDaily.endDate.toISOString();

    let datesWeekly = getIntervalDatesForElement( e, true );
    datesWeekly.startDate = datesWeekly.startDate.toISOString();
    datesWeekly.endDate = datesWeekly.endDate.toISOString();

    let dates = {
      daily: datesDaily,
      weekly: datesWeekly
    };

    modal.find( '.modal-body' ).html( '' );
    modal.find( '.modal-body' ).append( `<h3>${KPI_PLANNING_ADHESION_TITLE}</h3>` ).css( { 'text-align': 'center' } );

    let graphContainerModal = $( '<div class="graphsModalContainer">' );
    const kpisRate = $( '<div class="kpisRate">' );
    graphContainerModal.append( kpisRate );

    $( modal ).find( '.modal-body' ).append( graphContainerModal );
    try {
      modal.find( '.modal-body' ).css( { 'cursor': 'progress' } );

      setTimeout( async () => {
        let dataAdhesionByUser = await AJAXRequestGRaphics( API_URLS.adhesion.users, taskmanagers, filters, dates );
        setPlanningAdhesionByUsers( dataAdhesionByUser );
        let dataAdhesionByTheme = await AJAXRequestGRaphics( API_URLS.adhesion.themes, taskmanagers, filters, dates );
        setPlanningAdhesionByTheme( dataAdhesionByTheme );
        modal.find( '.modal-body' ).css( { 'cursor': 'auto' } );
        modal.find( '.kpisRate' ).css( { 'opacity': 1 } );
        modal.modal( 'show' );
      }, 200 );
    } catch ( e ) {
      console.log( 'Error ! ', e );
    }

    function setPlanningAdhesionByUsers( dataPlanningByUser ) {
      const elemContModal = $( `<div class="${nameHTML}"></div>` );
      let verif = false;

      dataPlanningByUser.forEach( e => {
        if ( e.value > 0 ) verif = true;
      } );

      const elem = $( '<div id="planningByUser" class="graphDimensions"/>' );//.css( { 'margin': '20px' } );
      elemContModal.html( elem );
      kpisRate.append( elemContModal );

      //$( graphContainerModal ).append( elem );
      const maxWidth = modal.find( '.modal-dialog' ).css( 'max-width' );
      modal.find( '.modal-dialog' ).css( { 'max-width': '80%' } );

      modal.on( 'hide.bs.modal', function() {
        modal.find( '.modal-dialog' ).css( { 'max-width': maxWidth } );
      } );

      let setData = () => {
        dataPlanningByUser.forEach( d => {
          d.label = d.label.split( ' ' )
            .map( str => { return str.substring( 0, 1 ).toUpperCase(); } )
            .join( '' );
          d.textColor = '#000000';
          d.value = Math.round( d.value );
        } );

        let labelUsers = dataPlanningByUser.map( e => { return e.label; } );

        let values = dataPlanningByUser.map( e => {
          return {
            value: e.value,
            itemStyle: { color: 'rgba(0, 170, 196, 0.5)' }
          };
        } );

        let opt = drawGraphicWithoutGoal( labelUsers, values, BY_USER, KPI_PLANNING_ADHESION_TOOLTIP );
        return opt;
      };

      return new Promise( ( resolve, reject ) => {
        setTimeout( () => {
          const chart = echarts.init( $( elem )[ 0 ] );
          const opt = ( verif ) ? setData() : setNoData( BY_USER );
          chart.setOption( opt );
          resolve();
        }, 500 );
      } );
    }

    function setPlanningAdhesionByTheme( dataPlanningByTheme ) {
      const elemContModal = $( `<div class="${nameHTML}"></div>` );
      let verif = false;

      dataPlanningByTheme.forEach( e => { if ( e.value > 0 ) verif = true; } );
      const elem = $( '<div id="planningByTheme" class="graphDimensions"></div>' );//.css( { 'margin': '20px' } );
      elemContModal.html( elem );
      kpisRate.append( elemContModal );

      //$( graphContainerModal ).append( elem );

      let setData = () => {
        dataPlanningByTheme.forEach( d => {
          d.label = d.label.split( ' ' )
            .map( str => { return str.substring( 0, 3 ).toUpperCase(); } )
            .join( '' );

          d.bgColor   = d.color || '#8abde8';
          d.textColor = '#000000';
          d.value     = Math.round( d.value );
        } );

        let labelTheme = dataPlanningByTheme.map( e => { return e.label; } );

        let values = dataPlanningByTheme.map( e => {
          return {
            value: e.value,
            itemStyle: { color: e.bgColor }
          };
        } );

        let opt = drawGraphicWithoutGoal( labelTheme, values, BY_THEME, KPI_PLANNING_ADHESION_TOOLTIP );
        return opt;
      };

      const chart = echarts.init( $( elem )[ 0 ] );
      const opt = ( verif ) ? setData() : setNoData( BY_THEME );
      chart.setOption( opt );
    }
  }

  async function createButtonActionForConformity( e ) {
    const modal = $( '#modal-general-confirm' );
    $( modal ).find( '.modal-title' ).html( e.label_month );

    let datesDaily = getIntervalDatesForElement( e, false );
    datesDaily.startDate = datesDaily.startDate.toISOString();
    datesDaily.endDate = datesDaily.endDate.toISOString();

    let datesWeekly = getIntervalDatesForElement( e, true );
    datesWeekly.startDate = datesWeekly.startDate.toISOString();
    datesWeekly.endDate = datesWeekly.endDate.toISOString();

    let dates = {
      daily: datesDaily,
      weekly: datesWeekly
    };

    $( modal ).find( '.modal-body' ).html( '' );
    $( modal ).find( '.modal-body' ).append( `<h3>${KPI_CONFORMITY_AUDITED_CARDS}</h3>` ).css( { 'text-align': 'center' } );

    let graphContainerModal = $( '<div class="graphsModalContainer">' );
    const kpisRate = $( '<div class="kpisRate">' );
    graphContainerModal.append( kpisRate );

    $( modal ).find( '.modal-body' ).append( graphContainerModal );

    try {
      $( modal ).find( '.modal-body' ).css( { 'cursor': 'progress' } );
      $( modal ).modal( 'show' );
      setTimeout( async () => {
        let dataConformityByUser = await AJAXRequestGRaphics( API_URLS.conformity.users, taskmanagers, filters, dates );
        setPlanningConformityByUser( dataConformityByUser );
        let dataConformityByTheme = await AJAXRequestGRaphics( API_URLS.conformity.themes, taskmanagers, filters, dates );
        setPlanningConformityByTheme( dataConformityByTheme );
        $( modal ).find( '.modal-body' ).css( { 'cursor': 'auto' } );
        $( modal ).find( '.kpisRate' ).css( { 'opacity': 1 } );
      }, 200 );
    } catch ( e ) {
      console.log( 'Error ! ', e );
    }

    function setPlanningConformityByUser( dataConformityByUser ) {
      const elemContModal = $( `<div class="${nameHTML}"></div>` );
      let verif = false;
      dataConformityByUser.forEach( e => { if ( e.value > 0 ) verif = true; } );
      const elem = $( '<div id="conrofmityByUser" class="graphDimensions"></div>' );//css( { 'margin': '20px' } );
      elemContModal.html( elem );
      kpisRate.append( elemContModal );

      //$( graphContainerModal ).append( elem );
      $( modal ).find( '.modal-dialog' ).css( { 'max-width': '80%' } );

      let setData = () => {
        dataConformityByUser.forEach( function( d ) {
          d.label = d.label.split( ' ' )
            .map( function( str ) { return str.substring( 0, 1 ).toUpperCase(); } )
            .join( '' );

          d.textColor = '#000000';
          d.value = Math.round( d.value );
        } );
        let labelUsers = dataConformityByUser.map( e => {return e.label;} );
        let values = dataConformityByUser.map( e => {
          return {
            value: e.value,
            itemStyle: {
              color: 'rgba(0, 170, 196, 0.5)'
            }
          };
        } );

        let opt = drawGraphicWithoutGoal( labelUsers, values, BY_USER, KPI_CONFORMITY_AUDITED_TOOLTIP );
        return opt;
      };

      return new Promise( ( resolve, reject ) => {
        setTimeout( () => {
          const chart = echarts.init( $( elem )[ 0 ] );
          const opt = ( verif ) ? setData() : setNoData( BY_USER );
          chart.setOption( opt );
          resolve();
        }, 500 );
      } );
    }

    function setPlanningConformityByTheme( dataConformityByThemes ) {
      const elemContModal = $( `<div class="${nameHTML}"></div>` );
      let verif = false;

      dataConformityByThemes.forEach( e => {if ( e.value > 0 ) verif = true;} );
      const elem = $( '<div id="conformityByTheme" class="graphDimensions"></div>' );//.css( { 'margin': '20px' } );
      elemContModal.html( elem );
      kpisRate.append( elemContModal );

      //$( graphContainerModal ).append( elem );

      let setData = () => {
        dataConformityByThemes.forEach( function( d ) {
          d.label = d.label.split( ' ' )
            .map( str => { return str.substring( 0, 3 ).toUpperCase(); } )
            .join( '' );

          d.bgColor = d.color || '#8abde8';
          d.textColor = '#000000';
          d.value = Math.round( d.value );
        } );

        let labelTheme = dataConformityByThemes.map( e => {return e.label;} );
        let values = dataConformityByThemes.map( e => {
          return {
            value: e.value,
            itemStyle: {
              color: e.bgColor
            }
          };
        } );
        let opt = drawGraphicWithoutGoal( labelTheme, values, BY_THEME, KPI_CONFORMITY_AUDITED_TOOLTIP );
        return opt;
      };

      const chart = echarts.init( document.getElementById( 'conformityByTheme' ) );
      const opt = ( verif ) ? setData() : setNoData( BY_THEME );
      chart.setOption( opt );
    }

  }

  $( elemCont ).append( btns );

  myChart.on( 'click', function( event ) {
    switch ( nameHTML ) {
    case 'planningAdhesionContainer' : {
      createButtonActionForAdhesion( event.data );
      break;
    }
    case 'planningConformityContainer' : {
      createButtonActionForConformity( event.data );
      break;
    }
    }
  } );

  let tooltip = '';
  switch ( nameHTML ) {
  case 'planningAdhesionContainer' : {
    title = KPI_PLANNING_ADHESION_TITLE;
    tooltip = KPI_PLANNING_ADHESION_TOOLTIP;
    break;
  }
  case 'planningConformityContainer' : {
    title = KPI_CONFORMITY_AUDITED_CARDS;
    tooltip = KPI_CONFORMITY_AUDITED_TOOLTIP;
    break;
  }
  }

  $( titleContainer ).find( 'b' ).html( title );

  let opt = null;
  if ( taskmanagers.length == 1 ) {
    opt = drawGraphicWithGoal( months, values, title, tooltip );
  }  else {
    opt = drawGraphicWithoutGoal( months, values, '', tooltip );
  }

  myChart.setOption( opt );
  //$( '#principalContent-kpi .kpisRate' ).css( { 'opacity': 1 } );

  window.addEventListener( 'resize', function() {
    myChart.setOption( opt, true );
  } );

  verifyScreen();
  Evnt.emit( 'Graphic Set' );
}

/**
 * Create options graphic with goals on it
 * @param {Array} labels : Bar labels
 * @param {Array} values : Data values
 * @param {String} txt : Title of chart
 * @param {String} tooltip : Tooltip text to show in bars
 * @returns : Options of the chart
 */
function drawGraphicWithGoal( labels, values, txt, tooltip ) {
  // Specify the configuration items and data for the chart*
  let { infGoals, goal, limitGoal, supGoal } = calculValuesChartWithGoals( values );

  var option = {
    tooltip: {
      trigger: 'axis',
      axisPointer: {
        type: 'cross',
        label: {
          formatter: params => {
            if ( isNaN( Math.round( params.value ) ) ) {
              return params.value;
            } else {
              const roundedValue = Math.round( params.value );
              return `${roundedValue} %`;
            }
          }
        }
      },
      formatter: params  => {
        let goal = parseInt( values[ params[ 1 ].dataIndex ].goal );
        goal = isNaN( goal ) ? 0 : goal;
        return `<div style="display:inline-flex; flex-direction: column; align-items: flex-start;" class="tooltipGraph">
                  <div style="display:inline-flex; align-items: flex-start; flex-direction: row; margin-bottom: 15px; margin-left:0; padding:0" class="tooltipGraph">
                    <div style="height: 20px; width: 20px; background-color: rgba(0, 170, 196, 0.5); margin-right:10px;" class="tooltipGraph">
                    </div>
                      <span>${tooltip} ${( parseInt( values[ params[ 1 ].dataIndex ].value ) + ' %' )}</span>
                  </div>
                  <div style="display:inline-flex; flex-direction: row" class="tooltipGraph">
                    <div style="height: 20px; width: 20px; background-color: rgba(74,194,22,0.5); margin-right:10px; margin-left:0" class="tooltipGraph">
                    </div>
                    <span>${GOAL} ${( goal + ' %' )}</span>
                  </div>
                </div>`;
      }
    },
    grid: {
      left: '0%',
      right: '0%',
      bottom: '10%',
      top: '10%',
      containLabel: true
    },
    xAxis: [
      {
        type: 'category',
        data: labels,
        axisTick: {
          alignWithLabel: true
        }
      }
    ],
    yAxis: [
      {
        type: 'value',
        max: 100,
        axisLabel: {
          formatter: params  => {
            return params + ' %';
          }
        }
      }
    ],
    series: [
      {
        name: 'InitValue',
        type: 'bar',
        stack: 'a',
        silent: true,
        itemStyle: {
          borderColor: 'transparent',
          color: 'transparent'
        },
        data: [ 0, 0, 0, 0 ]
      },
      {
        name: 'Goal',
        type: 'bar',
        barWidth: '60%',
        data: infGoals,
        stack: 'a',
        showBackground: true,
        backgroundStyle: {
          color: 'rgba(180, 180, 180, 0.2)'
        },
      },
      {
        name: 'Goal',
        type: 'bar',
        silent: true,
        stack: 'a',
        itemStyle: {
          borderColor: 'transparent',
          color: 'transparent'
        },
        data: goal
      },
      {
        name: 'LimitGoal',
        type: 'bar',
        stack: 'a',
        data: limitGoal
      },
      {
        name: 'SuperiorGoal',
        type: 'bar',
        stack: 'a',
        data: supGoal
      },
    ],
    /*title: [
      {
        top: '2%',
        left: 'center',
        text: txt,
        textStyle: txtStyle
      }
    ],*/
  };

  // Display the chart using the configuration items and data just specified.
  return option;
}

/**
 * Create options graphic without goals
 * @param {Array} labels : Bar labels
 * @param {Array} values : Data values
 * @param {String} txt : Title of chart
 * @param {String} tooltip : Tooltip text to show in bars
 * @returns : Options of the chart
 */
function drawGraphicWithoutGoal( labels, values, txt, tooltip ) {
  // Specify the configuration items and data for the chart*
  var option = {
    tooltip: {
      trigger: 'axis',
      axisPointer: {
        type: 'shadow',
        label: {
          formatter: params => {
            if ( isNaN( Math.round( params.value ) ) ) {
              return params.value;
            } else {
              const roundedValue = Math.round( params.value );
              return `${roundedValue} %`;
            }
          }
        }
      },
      formatter: params  => {
        return `<span>${tooltip} ${( parseInt( values[ params[ 0 ].dataIndex ].value ) + ' %' )}</span>`;
      }
    },
    grid: {
      left: '3%',
      right: '4%',
      bottom: '3%',
      containLabel: true
    },
    xAxis: [
      {
        type: 'category',
        data: labels,
        axisTick: {
          alignWithLabel: true
        }
      }
    ],
    yAxis: [
      {
        type: 'value',
        max: 100,
        axisLabel: {
          formatter: params  => {
            return params + ' %';
          }
        }
      }
    ],
    series: [
      {
        name: tooltip,
        type: 'bar',
        barWidth: '60%',
        data: values,
        stack: 'a',
        showBackground: true,
        backgroundStyle: {
          color: 'rgba(180, 180, 180, 0.2)'
        },
      }
    ],
    title: [
      {
        top: '2%',
        left: 'center',
        text: txt,
        textStyle: txtStyle
      }
    ],
  };

  // Display the chart using the configuration items and data just specified.
  return option;
}

/**
 * Create options for pareto graphic
 * @param {Array} labels : Array of strings representing the name of themes
 * @param {Array} values : The countnok  values for each theme
 * @param {String} tooltip : Tooltip text
 * @returns
 */
function drawGraphicPareto( labels, values, tooltip ) {
  // Specify the configuration items and data for the chart*
  const maxCount = Math.max( ...values.map( v => v.value ) ) + 5;
  var option = {
    tooltip: {
      formatter: params  => {
        let color = values[ params.dataIndex ].theme.color;
        return `<div style="display:inline-flex; flex-direction: column; align-items: flex-start;">
          <div style="display:inline-flex; flex-direction: row">
            <div style="height: 20px; width: 20px; background-color: ${color}; margin-right:10px; margin-left:0"></div>
            <span>${( values[ params.dataIndex ].theme.name )}</span>
          </div>
          <div style="display:inline-flex; align-items: flex-start; flex-direction: row; margin-top: 15px; margin-left:0; padding:0">
            <span>${tooltip} : ${( parseInt( values[ params.dataIndex ].value ) )}</span>
          </div>
        </div>`;
      }
    },
    xAxis: [
      {
        type: 'category',
        data: labels,
        axisTick: {
          alignWithLabel: true
        }
      }
    ],
    yAxis: [
      {
        type: 'value',
        max: maxCount,
        axisLabel: {
          formatter: params  => {
            return params;
          }
        }
      }
    ],
    series: [
      {
        name: tooltip,
        type: 'bar',
        barWidth: '60%',
        data: values,
        stack: 'a',
        showBackground: true,
        backgroundStyle: {
          color: 'rgba(180, 180, 180, 0.2)'
        },
      }
    ]
  };

  // Display the chart using the configuration items and data just specified.
  return option;
}

/**
 * Values containing the goals
 * @param {Array} values Array containing values and goals
 * @returns
 */
function calculValuesChartWithGoals( values ) {
  // Value
  let infGoals = values.map( v => {
    let obj = {
      ...v,
    };
    obj.goal = !isNaN( obj.goal ) ? obj.goal : 0;
    let res = 0;

    if ( obj.goal <= obj.value ) {
      res = obj.goal >= 1 ? obj.goal - 1 : obj.goal;
    } else if ( obj.goal > obj.value ) {
      res = obj.value;
    }

    obj.value = res;
    return obj;
  } );

  let goal = values.map( v => {
    let obj = {
      ...v,
      itemStyle: {
        color: 'rgba(74,194,22,0)'
      }
    };
    obj.goal = !isNaN( obj.goal ) ? obj.goal : 0;
    if ( obj.goal > obj.value ) {
      obj.value = obj.goal - obj.value - 1;
    } else {
      obj.value = 0;
    }

    return obj;
  } );

  let limitGoal = goal.map( () => {
    return { value: 1 };
  } );

  let supGoal = values.map( v => {
    let obj = { ...v };
    obj.goal = !isNaN( obj.goal ) ? obj.goal : 0;
    obj.value = obj.value - obj.goal;
    obj.value = obj.value < 0 ? 0 : obj.value;
    return obj;
  } );

  return  {
    infGoals: infGoals,
    goal: goal,
    limitGoal: limitGoal,
    supGoal: supGoal
  };
}

function setNoData( txt ) {
  let opt = drawGraphicWithoutGoal( [], [], txt );
  opt.title = [
    {
      top: '4%',
      left: 'center',
      text: txt,
      textStyle: txtStyle
    },
    {
      top: '50%',
      left: 'center',
      text: NO_DATA,
      textStyle: {
        fontSize: '20',
        color: '#FF2D00'
      }
    },
  ];
  return opt;
}

/**
 * Get the interval dates in the selected month in the chart
 * @param {*} e : element clicked
 * @param {boolean} weeklyMode : if we want to take in count until friday
 */
function getIntervalDatesForElement( e, weeklyMode ) {
  let currentDate = moment();
  let selectedStart = moment( `${e.years}-${e.month}`, 'YYYY-MM' );
  let endDate;

  if ( selectedStart.month() == currentDate.month() ) {
    // If we select the same month as the current month

    if ( weeklyMode ) {
      // If we select the same month as the current month
      // Select the last day in week that belongs to the selected month
      let setEndDate = currentDate.clone();

      while ( setEndDate.month() == selectedStart.month() && setEndDate.day() <= 5 ) {
        let setEndDateTemp = setEndDate.clone().add( 1, 'day' );
        if ( setEndDateTemp.month() === selectedStart.month() && setEndDateTemp.day() <= 5 ) {
          setEndDate = setEndDateTemp;
        } else {
          break;
        }
      }
      endDate = setEndDate.clone().endOf( 'day' );
    } else {
      // Set the endDate today
      endDate = currentDate.clone().endOf( 'day' );
    }
  } else {
    // If is not the current month, we can select the last day of the month
    endDate = selectedStart.clone().endOf( 'month' );
  }

  // Setting offsets
  let offsetStart = selectedStart.utcOffset();
  let offsetEnd = endDate.utcOffset();

  return {
    startDate: selectedStart,
    endDate: endDate,
    offsetStart: offsetStart,
    offsetEnd: offsetEnd
  };
}